import { Location } from "../location.js";
import { ExpandAreaCircular } from "./expandAreaCircular.js";

/**
 * Finds a list of Location objects that connect the two params linearly.\
 * Line generation algorithm from https://www.tutorialspoint.com/computer_graphics/line_generation_algorithm.htm#:~:text=Step%201%20%E2%88%92%20Get%20the%20input,difference%20between%20two%20end%20points.&text=Step%203%20%E2%88%92%20Based%20on%20the,coordinate%3B%20otherwise%20in%20y%20coordinate.
 * @param {*} location1 First location to connect 
 * @param {*} location2 Second location to connect
 * @returns List of Locations that connect location1 and location2 linearly
 */
function createStraightLine (location1, location2){
    let dx = location2.x - location1.x;
    let dy = location2.y - location1.y;

    const absDX = Math.abs(dx);
    const absDY = Math.abs(dy);
    let steps;
    if(absDX > absDY){
        steps = absDX;
    }else{
        steps = absDY;
    }

    const xIncrement = dx/steps;
    const yIncrement = dy/steps;
    
    const line = [];
    let x = location1.x;
    let y = location1.y;
    for(let i = 0; i < steps; i++){
        x += xIncrement;
        y += yIncrement;

        line.push(new Location({...location1.baseLocation}, Math.round(x), Math.round(y)));
    }

    return line;
}

/**
 * Expands locations on the line, making the line appear like it's made up of
 * individual circles.
 * @param {*} line List of Location objects
 * @returns All Location objects generated by the algorithm 
 */
function fattenLine(line, rng, min, max, step){
    let fullyFattenedLine = [];
    const expandAreaCircular = new ExpandAreaCircular();

    //Incrementing by a number greater than 1 leads to mor intersting shapes.
    for(let i = 0; i < line.length; i += step){
        //If the location does not appear in the fattened line
        if(fullyFattenedLine.filter(location => location.comparePositions(line[i])).length === 0){
            fullyFattenedLine = fullyFattenedLine.concat(
                expandAreaCircular.runAlgorithm(
                    line[i], fullyFattenedLine, rng, min, max));
        }
    }

    return fullyFattenedLine;
}

const lineAlgorithms = [
    createStraightLine
]

export class ExpandAreaConnect{
    /**
     * Expands the initial position by finding another position of the same type
     * and connecting them. The line that connects them may be linear or a curve,
     * chosen randomly.
     * @param {*} inputLocation Initial location 
     * @param {*} prevLocations List of locations that are already set
     * @param {*} rng Random number generator
     * @return List of new locations generated by the algorithm. 
     * @return List containing only location if another valid location for conecting wasn't found. 
     */
    runAlgorithm(inputLocation, prevLocations, rng, minWidth = 1, maxWidth = 4, fattenLineStep = 4){  
        //console.log(inputLocation);
        
        //Create a list of all locations in prevlocations that match the given location's type.
        //Then choose one of the locations at random.
        const chooseFrom = prevLocations.filter(value => {
            if(!value){
                return false;
            }
            
            const baseLocation = value.baseLocation;
            if(baseLocation){
                return !inputLocation.comparePositions(value) && inputLocation.compareBaseLocations(value);
            }
        });

        const connectTo = chooseFrom[Math.floor(rng() * chooseFrom.length)];
        if(!connectTo || !(connectTo instanceof Location)){
            return [inputLocation];
        }

        const connectToLocation = connectTo.getClone();

        let line1 = lineAlgorithms[Math.floor(rng() * lineAlgorithms.length)](inputLocation, connectToLocation);
        let line2 = fattenLine(line1, rng, minWidth, maxWidth, fattenLineStep);

        return line2;
    }
}